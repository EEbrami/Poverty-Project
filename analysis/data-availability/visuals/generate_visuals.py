#!/usr/bin/env python3
"""
Generate data availability visualizations for country-by-year CSV data.

This script now exclusively generates professional-grade PNG and PDF heatmaps.
"""

import argparse
import os
import re
from typing import List, Tuple, Optional

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns


def parse_args():
    """Parse command-line arguments, including visualization options."""
    parser = argparse.ArgumentParser(
        description="Generate data availability visualizations from CSV"
    )
    parser.add_argument(
        "--csv-path",
        required=True,
        help="Path to the input CSV file (relative to repo root)",
    )
    parser.add_argument(
        "--start-year",
        type=int,
        default=None,
        help="Clip to years >= start_year (optional)",
    )
    parser.add_argument(
        "--end-year",
        type=int,
        default=None,
        help="Clip to years <= end_year (optional)",
    )
    parser.add_argument(
        "--tick-interval",
        type=int,
        default=5,
        help="Tick mark spacing for x-axis (default: 5)",
    )
    parser.add_argument(
        "--glyph",
        type=str,
        default="#",
        help="Character to render for available data (default: #)",
    )
    parser.add_argument(
        "--include-universal",
        type=str,
        default="true",
        help="Include Universal row showing full availability (default: true)",
    )
    
    # NEW ARGUMENTS FOR VISUALIZATION CONTROL
    parser.add_argument(
        "--visualization-mode",
        type=str,
        default="vertical-grid-5yr",
        help="Defines the grid style (retained for compatibility)",
    )
    parser.add_argument(
        "--output-format",
        type=str,
        # CRITICAL CHANGE: Only image formats are generated by default.
        default="png,pdf", 
        help="Comma-separated list of output formats (e.g., png, pdf, svg)",
    )
    
    return parser.parse_args()


def load_csv_with_years(csv_path: str) -> Tuple[pd.DataFrame, List[int], str]:
    """Load CSV and detect entity column and year columns."""
    if not os.path.exists(csv_path):
        raise FileNotFoundError(f"CSV file not found: {csv_path}")
    
    df = pd.read_csv(csv_path)
    
    if "countries" in df.columns:
        entity_col = "countries"
    else:
        entity_col = df.columns[0]
    
    year_cols = []
    for col in df.columns:
        if col == entity_col:
            continue
        if isinstance(col, str) and re.fullmatch(r"\d+", col.strip()):
            year_cols.append(col.strip())
        elif isinstance(col, (int, np.integer)):
            year_cols.append(str(col))
    
    if not year_cols:
        raise ValueError("No year columns detected (columns with purely numeric names)")
    
    years = sorted([int(y) for y in year_cols])
    
    return df, years, entity_col


def compute_longest_streak(availability_row: np.ndarray) -> int:
    """Compute the longest contiguous streak of available data."""
    max_streak = 0
    current_streak = 0
    
    for val in availability_row:
        if val == 1:
            current_streak += 1
            max_streak = max(max_streak, current_streak)
        else:
            current_streak = 0
    
    return max_streak


def generate_availability_data(
    df: pd.DataFrame,
    years: List[int],
    entity_col: str,
    include_universal: bool,
    start_year: Optional[int] = None,
    end_year: Optional[int] = None,
) -> Tuple[List[str], pd.DataFrame]:
    """Generate the sorted entity list and the binary availability matrix."""
    filtered_years = years
    if start_year is not None:
        filtered_years = [y for y in filtered_years if y >= start_year]
    if end_year is not None:
        filtered_years = [y for y in filtered_years if y <= end_year]
    
    if not filtered_years:
        raise ValueError("No years remain after filtering")
    
    year_cols = [str(y) for y in filtered_years]
    
    data = []
    entity_data = [] 
    
    for _, row in df.iterrows():
        entity = str(row[entity_col])
        availability = []
        for year_str in year_cols:
            if year_str in df.columns:
                val = row[year_str]
                availability.append(1 if pd.notna(val) else 0)
            else:
                availability.append(0)
        
        availability_array = np.array(availability)
        longest_streak = compute_longest_streak(availability_array)
        
        data.append(availability)
        entity_data.append((entity, longest_streak))

    matrix = pd.DataFrame(data, index=[e[0] for e in entity_data], columns=filtered_years)
    
    entity_data.sort(key=lambda x: x[1])
    sorted_entities = [e[0] for e in entity_data]
    matrix = matrix.loc[sorted_entities]
    
    if include_universal:
        matrix.loc["Universal"] = 1
        sorted_entities.append("Universal")
        
    return sorted_entities, matrix


def write_image_outputs(
    matrix: pd.DataFrame,
    output_dir: str,
    slug: str,
    args,
):
    """Generate image outputs (PNG/PDF/SVG) using Matplotlib/Seaborn heatmap."""
    
    # CRITICAL FIX: Use the matrix directly. 1=Available (Black), 0=Missing (White).
    image_matrix = matrix.copy() 
    
    plt.figure(figsize=(12, max(6, len(image_matrix) * 0.3)))
    
    # Generate the heatmap
    ax = sns.heatmap(
        image_matrix,
        cmap="binary", # Maps high values (1/Available) to Black. Low (0/Missing) to White.
        linewidths=0.5, # Adds definite grid lines between cells (solving alignment issue)
        linecolor="gray",
        cbar=False,
        xticklabels=matrix.columns.values,
        yticklabels=matrix.index.values,
        square=True,
    )
    
    if args.tick_interval > 1:
        # Only show labels at the tick interval positions for cleaner X-axis
        xtick_labels = [
            label if year % args.tick_interval == 0 else ""
            for year, label in zip(matrix.columns, ax.get_xticklabels())
        ]
        ax.set_xticklabels(xtick_labels)

    ax.set_title(f"Data Availability for {slug} ({matrix.columns.min()}-{matrix.columns.max()})", fontsize=14)
    ax.set_ylabel("Entities (Sorted by Shortest Streak)", fontsize=12)
    ax.set_xlabel("Year", fontsize=12)
    
    plt.tight_layout()

    formats = [f.strip() for f in args.output_format.lower().split(",")]
    
    for fmt in formats:
        if fmt in ("png", "pdf", "svg"):
            output_path = os.path.join(output_dir, f"{slug}-availability.{fmt}")
            plt.savefig(output_path)
            print(f"Generated image output: {output_path}")

    plt.close()


def main():
    """Main entry point."""
    args = parse_args()
    
    include_universal = args.include_universal.lower() in ("true", "1", "yes", "y")
    
    df, years, entity_col = load_csv_with_years(args.csv_path)
    
    entity_names, availability_matrix = generate_availability_data(
        df,
        years,
        entity_col,
        include_universal,
        args.start_year,
        args.end_year,
    )
    
    csv_filename = os.path.basename(args.csv_path)
    slug = os.path.splitext(csv_filename)[0]
    
    output_dir = os.path.join(
        os.path.dirname(__file__),
        ""
    )
    os.makedirs(output_dir, exist_ok=True)

    formats = [f.strip() for f in args.output_format.lower().split(",")]

    # Only generate image outputs (PNG/PDF/SVG)
    if "png" in formats or "pdf" in formats or "svg" in formats:
        write_image_outputs(availability_matrix, output_dir, slug, args)
        

if __name__ == "__main__":
    main()
